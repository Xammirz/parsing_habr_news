[
    {
        "url": "https://habr.com/ru/company/ruvds/blog/587724/",
        "title": "Разработка настоящих компонентов: блок сообщения Facebook Messenger",
        "teg": "CSSдизайнruvds_перевод",
        "body": "Смесь любопытства и тяги к исследованиям снова привели меня к системе обмена сообщениями Facebook. Я уже изучал компоненты Facebook и писал об этом. Сейчас я обратил внимание на то, что в одни только блоки для вывода сообщений чата вложена огромная работа. На первый взгляд может показаться, что разработка компонента, реализующего чат — это просто, что у составных частей такого компонента будет не особенно много вариаций.\n\r\nЕсли же вникнуть в тему работы с сообщениями, то окажется, что один только интерфейс чата — это такая штука, при создании которой нужно учесть невероятное количество деталей. Особенно — если это чат некоей платформы, сравнимой по масштабам с Facebook.\n\n\n\r\nВ этой статье я расскажу об устройстве компонента, представляющего собой блок сообщения Facebook Messenger, покажу варианты его стилизации, поделюсь некоторыми интересными находками.\n\nПредварительные сведения\r\nДля того чтобы было понятнее — сразу показываю блок сообщения, о котором пойдёт речь.\n\n\nБлок сообщения\n\r\nКажется, что всё тут устроено довольно просто. Но если задуматься о различных вариантах такого компонента, получится, что это совсем не так. Я, чтобы лучше понять ход мыслей дизайнеров Facebook, воссоздал разные варианты блока сообщений в Figma.\n\n\nРазновидности блоков сообщений\n\r\nНаписание HTML- и CSS-кода для подобного компонента — это нетривиальная (но очень интересная) задача. В данном случае компонент чата должен быть динамическим для того чтобы справиться с выводом самого разного содержимого и служебной информации, для поддержки тем оформления и вывода текстов на разных языках.\n\r\nЯ, чтобы избежать путаницы, не буду хвататься сразу за всё. Вместо этого расскажу об анатомии блока сообщений.\n\nАнатомия блока сообщений\r\nЯ употребил тут слово «анатомия» из-за того, что мне нравится, так сказать, «препарировать» пользовательские интерфейсы. Я в такие моменты прямо-таки вижу, как я, в лаборатории, за микроскопом, исследую устройство компонентов.\n\r\nДля начала мне хотелось бы обратить ваше внимание на то, что структура отправленных и полученных сообщений различается.\n\n\nОкно чата, LTR-язык\n\r\nЕсли вы пишете слева направо (LTR, Left-To-Right), как, например, принято в английском языке, тогда блок с вашими сообщениями, синий, будет справа, а блок собеседника (серый) — слева.\n\r\nЕсли же вы пользуетесь RTL-языком (Right-To-Left, справа налево), например — арабским, тогда блоки поменяются местами.\n\n\nОкно чата, RTL-язык\n\r\nУчитывая это — рассмотрим структуру компонента, реализующего блок сообщения.\n\n\nВнешний контейнер (Outer container), внутренний контейнер (Inner container), аватар пользователя (Avatar), разделитель (Spacer), меню действий (Actions Menu), область вывода сообщения (Bubble), область вывода состояния сообщения (Status)\n\r\nБлок сообщения чата состоит из следующих частей:\n\n\nВнешний контейнер, включающий в себя область вывода состояния сообщения, внутренний контейнер, аватар.\nВнутренний контейнер, в состав которого входят такие элементы, как область вывода сообщения, меню действий, разделитель.\n\r\nДля того чтобы было понятнее — на следующем рисунке внешний и внутренние контейнеры отделены друг от друга.\n\n\nВнешний и внутренний контейнеры блока сообщения\n\r\nВозможно, вы обратите внимание на то, что область для вывода аватара очень мала. А где сам аватар? Это — хороший вопрос.\n\r\nВыше показана структура сообщения в том виде, в котором его видит тот, кто это сообщение отправил. Если же речь идёт о принятом сообщении, то оно будет выведено в блоке, представляющим собой, по большей части, зеркальное отражение вышерассмотренного блока. Я, исследуя возможность создания этого «зеркального» блока без необходимости разработки отдельного компонента, кое-что выяснил.\n\r\nА именно, положение первого и последнего элементов блока (аватара и состояния сообщения) не зависит от того, кто отправил сообщение. Они «отражаются» лишь в том случае, если меняется направление вывода текста (LRT на RTL или наоборот). Вот ещё некоторые наблюдения:\n\n\nМесто для аватара зарезервировано даже в том случае, если аватар в нём не выводится. Если вы отправляете сообщение — это место будет пустым.\nНо если кто-то отправляет сообщение вам — в месте для аватара будет выведено соответствующее изображение.\n«Отражается» лишь внутренняя часть блока сообщения (внутренний контейнер), которая содержит поле для вывода содержимого сообщения, меню и разделитель.\n\n\nБлоки отправленного и принятого сообщений\n\r\nУ такого решения есть одна ценная особенность: он отлично подходит и для LTR макетов, пример которого рассмотрен выше, и для RTL-макетов. Обратите внимание на то, что весь внешний контейнер автоматически «переворачивается» при использовании RTL-макетов.\n\n\nLTR- и RTL-макеты блока отправленного сообщения\n\r\nА вот — сводная схема, где показаны принятые и отправленные сообщения в LTR и RTL-исполнении.\n\n\nLTR- и RTL-макеты блока отправленных и принятых сообщений\n\r\nВыше я старался рассказывать об устройстве блока сообщений так, чтобы меня понял бы и тот, кто ничего не знает об HTML и CSS. В следующих разделах я расскажу о том, как реализовать все эти структуры в коде, уделив внимание их различным вариантам.\n\nБазовый HTML- и CSS-код\r\nВот как выглядит базовая структура блока сообщения в HTML:\n\n<div class=\"message\">\n    <div class=\"message__outer\">\n        <div class=\"message__avatar\"></div>\n        <div class=\"message__inner\">\n            <div class=\"message__bubble\"></div>\n            <div class=\"message__actions\"></div>\n            <div class=\"message__spacer\"></div>\n        </div>\n        <div class=\"message__status\"></div>\n    </div>\n</div>\n\r\nВот базовые стили:\n\n.message__outer {\n    display: flex;\n}\n\n.message__inner {\n    flex: 1;\n    display: flex;\n    flex-direction: row-reverse;\n}\n\r\nНиже показан результат визуализации этого кода (я, чтобы внести предельную ясность в повествование, выделил границы элементов).\n\n\nБазовый блок сообщения\n\r\nТеперь можно заняться стилизацией внутренних областей блока. А именно, речь идёт об области для вывода сообщения, о меню и о разделителе.\n\r\nВот CSS-код:\n\n.message__actions {\n    width: 67px;\n    padding-right: 5px;\n}\n\n.message__spacer {\n    flex: 1;\n}\n\n\nСтилизация внутренней части блока сообщения\n\r\nПолагаю, то, что меню назначена фиксированная ширина, объясняется следующими причинами:\n\n\nРезервирование пространства для предотвращения сдвига макета.\nУлучшение возможностей управления внутренней частью макета. Например, при стилизации области вывода сообщения нужно использовать свойство max-width. Может понадобиться вычесть ширину области меню из ширины области вывода сообщения.\n\r\nДля того чтобы обеспечить правильный вывод блока сообщения в области просмотра маленькой ширины, нужно обратить внимание на следующее:\n\n\nНеобходимо рассчитывать на то, что может возникнуть ситуация, когда элемент-разделитель, из-за нехватки места, придётся сжать.\nНужно предотвратить уменьшение размеров области меню в маленьких областях просмотра.\nНужно избежать чрезмерного растягивания блока вывода сообщения путём разбиения очень длинных слов.\n\n.message__bubble {\n    max-width: calc(100% - 67px);\n    overflow-wrap: break-word;\n}\n\n.message__actions {\n    flex-shrink: 0;\n}\n\r\nТеперь поговорим о стилизации области вывода состояния сообщения и области вывода аватара (прямых потомков внешнего контейнера).\n\nРабота с RTL- и LTR-текстами\r\nСтоит упомянуть, что область вывода сообщения поддерживает представление текстов, написанных на RTL- и LTR-языках, благодаря использованию HTML-атрибута dir со значением auto.\n\n<div dir=\"auto\"></div>\n\r\nЕсли в сообщении сначала был введён текст на RTL-языке (на арабском, например), то, даже если потом ввести текст на LTR-языке, он будет выровнен по правому краю.\n\r\nИ, аналогично, если сначала в поле был введён текст на LTR-языке (например — на английском), а потом — на RTL-языке, он будет выровнен по левому краю.\n\n\nВыравнивание текстов в сообщениях, где одновременно используются RTL- и LTR-языки\n\nСтилизация области вывода состояния сообщения\r\nОбласть, используемая для вывода состояния сообщения, представляет собой элемент-обёртку, в котором могут выводиться различные значки.\n\n\nОбласть вывода состояния сообщения\n\r\nВ данном контейнере могут выводиться различные элементы, указывающие, например, на то, что сообщение отправлено, доставлено или прочитано.\n\n\nРазличные значки, указывающие на состояние сообщения\n\r\nВот как выглядит HTML-разметка этого элемента:\n\n<div class=\"message__status\">\n    <span class=\"avatar\"></span>\n</div>\n\r\nЗдесь, для выравнивания дочернего элемента по нижнему краю контейнера, использован Flexbox-макет. Обратите внимание на то, что свойству flex-direction назначено значение column.\n\n.message__status {\n    width: 20px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: flex-end;\n}\n\r\nПри таком подходе дочерний элемент всегда будет прижат к нижней части контейнера. Даже тогда, когда высота блока вывода сообщения очень велика. Это важно для тех случаев, когда выводятся сообщения, содержащие очень длинные предложения, сообщения, состоящие из нескольких строк, или содержащие изображения.\n\n\nВысокие сообщения и область вывода состояния сообщения\n\r\nЕсли вы пользуетесь Facebook, то вы, возможно, обратили внимание на то, как действует значок, указывающий на то, что сообщение прочитано. А именно, когда отправленное сообщение видит адресат, выводится аватар. При отправке другого сообщения место для вывода состояния сообщения остаётся пустым, но другие элементы его не занимают.\n\n\nЗначки, указывающие на состояние сообщения\n\nСтилизация области вывода аватара отправителя сообщения\r\nУ элемента-обёртки для вывода аватара, по умолчанию, настроены свойства, задающие его горизонтальные поля, что позволяет зарезервировать место для аватара. Этот элемент оказывается пустым в том случае, если сообщение отправляете вы. А вот если сообщение отправляют вам — в этом элементе будет аватар отправителя.\n\r\nВот HTML-код:\n\n<div class=\"message__avatar\">\n    <img class=\"avatar\" src=\"ahmad.jpg\" alt=\"Photo of Ahmad Shadeed\">\n</div>\n\r\nВот — стили:\n\n.message__avatar {\n    padding-left: 6px;\n    padding-right: 8px;\n}\n\r\nКогда обёртка аватара пуста, её ширина будет составлять 14px (сумма размеров полей 6px и 8px).\n\n\nПустой элемент-обёртка для вывода аватара\n\r\nЕсли же речь идёт о просмотре принятого сообщения — в элементе-обёртке будет выведено изображение аватара размером 28x28.\n\n\nЭлемент-обёртка с аватаром\n\r\nДля того чтобы всё было бы предельно ясно — на следующем рисунке показаны элементы-обёртки аватара отправленного и полученного сообщения.\n\n\nОтправленное и полученное сообщения\n\nСтилизация меню\r\nС каждым сообщением может быть связан набор действий, представленных командами меню, выводимого при наведении указателя мыши на соответствующую область:\n\n\nРабота с эмотиконами.\nОтвет на сообщение или его цитирование.\nПересылка материалов сообщений (для сообщений с изображениями или видео).\nДополнительные команды меню (три точки).\n\r\nВот некоторые замечания по поводу этого меню:\n\n\nУ него есть правое поле в том случае, если речь идёт об области для вывода отправленного сообщения. В противном случае у него имеется левое поле.\nОно, для получателя сообщения, представлено в отражённом виде с помощью flex-direction: row-reverse. Стандартный порядок его вывода применяется при выводе собственных сообщений у отправителя этих сообщений.\n\r\nОсобенно мне тут нравится широкое использование Flexbox. Я прямо-таки счастлив, когда вижу нечто подобное.\n\r\nВот схема «отражения» области вывода меню при просмотре собственных и полученных сообщений.\n\n\nОбласть вывода меню в собственном и полученном сообщении\n\r\nЕсли сообщение очень длинное, а так же — при отправке изображений или видео, меню должно быть центровано по вертикали. Этого можно добиться с использованием Flexbox-инструментов для выравнивания материалов.\n\r\nВот разметка:\n\n<div class=\"message__actions\">\n    <ul class=\"menu\"></ul>\n</div>\n\r\nВот CSS-код:\n\n.message__actions {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    width: 67px;\n    padding-right: 5px;\n}\n\n\nВыравнивание меню при выводе длинных сообщений\n\r\nКак так получается? Дело в том, что если в сообщении имеется длинный текст или изображение — элемент .message__actions растянется так, чтобы соответствовать высоте родительского элемента. Это — стандартное поведение Flexbox-макетов. Мы можем этим воспользоваться для того чтобы отцентровать меню по вертикали.\n\r\nТеперь, когда мы разобрались с базовым блоком сообщений — поговорим о вариациях таких блоков.\n\nВывод нескольких блоков сообщений\r\nЕсли отправить кому-то подряд несколько сообщений — для вывода блоков сообщений будут использоваться элементы, углы которых скруглены по-разному, причём, эти блоки ещё и по-разному выглядят для отправленных и принятых сообщений.\n\n\nLTR- и RTL-макеты и различные блоки для вывода нескольких сообщений, отправленных или полученных друг за другом\n\r\nБолее того — области вывода сообщений меняются местами в LTR- и RTL-макетах. Хотелось бы мне, чтобы логические свойства border-radius пользовались бы достаточно хорошей поддержкой браузеров, позволяющей применять их в продакшне. Пока логические значения для свойств border-radius поддерживаются в браузере Chrome 89 (вышел 1 марта 2021 года).\n\r\nЕсли бы эти свойства пользовались широкой поддержкой браузеров, то нашу задачу с их помощью можно было бы решить примерно так:\n\n/* Отправитель, сообщения с синим фоном */\n\n/* Первое сообщение */\n.message--first .message__bubble {\n    border-end-end-radius: 4px;\n}\n\n/* Сообщение, находящееся в середине набора сообщений */\n.message--middle .message__bubble {\n    border-start-end-radius: 4px;\n    border-end-end-radius: 4px;\n}\n\n/* Последнее сообщение */\n.message--last .message__bubble {\n    border-start-end-radius: 4px;\n}\n\r\nЗнаю, что «двойные» переменные, в названиях которых есть нечто вроде end-end, могут, на первый взгляд, показаться непонятными. Поэтому попробую раскрыть их смысл с помощью следующего рисунка.\n\r\nИтак, у нас есть две оси (Block и Inline), каждая из них имеет значения start и end.\n\n\nLTR-макет\n\r\nЕсли речь идёт о RTL-макете, то Start и End оси Inline меняются местами. При таком подходе нам не нужно переназначать значение для радиуса и менять направление. Обратите внимание на то, что на следующем рисунке, если сравнить его с предыдущим, Inline Start и Inline End поменялись местами.\n\n\nRTL-макет\n\r\nЕсли вы хотите лучше разобраться с логическими CSS-свойствами — вот моя статья на эту тему.\n\nПоддержка вывода изображений\n\nОтправленное и принятое сообщения, содержащие изображения\n\r\nМожет показаться, что организовать поддержку вывода изображений разных размеров и обладающих различным соотношением сторон — это просто. Возможно, нужно всего лишь воспользоваться свойством max-width: 100% — и всё готово. Была у вас такая мысль? Но в случае с Facebook Messenger всё гораздо интереснее.\n\r\nКогда пользователь выгружает изображение — его ширина задаётся во встроенном CSS-коде. Там ещё имеется и свойство padding-bottom: 56.66% для обеспечения отзывчивости изображения (это — так называемый «padding hack»).\n\r\nВот HTML-код:\n\n<a class=\"image\" href=\"#\">\n    <div class=\"image__main\">\n        <div class=\"image__element\" style=\"width: 348.259px; \">\n            <div class=\"image__aspectRatio\" style=\"padding-bottom: 57.4286%\">\n                <div class=\"image__wrapper\">\n                    <img src=\"assets/thumb-1.png\" alt=\"\">\n                </div>\n            </div>\n        </div>\n    </div>\n</a>\n\r\nВот — стили:\n\n.image {\n    display: block;\n    border-radius: 18px;\n    border: 1px solid #0006;\n    overflow: hidden;\n}\n\n.image__main {\n    max-width: 480px;\n}\n\n.image__element {\n    max-width: 100%;\n    position: relative;\n}\n\n.image__aspectRatio {\n    position: relative;\n}\n\n.image__wrapper {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n}\n\n.image__wrapper img {\n    display: block; \n    max-width: 100%; \n    max-height: 200px;\n    width: 100%;\n    height: 100%;\n}\n\r\nВсе изображения должны подчиняться следующим правилам:\n\n\nМаксимальная ширина изображения — 480px.\nМаксимальная высота изображения — 200px.\nСоотношение сторон изображения не должно меняться при изменении его размеров.\nЕсли размеры изображения меньше вышеозначенных значений — оно должно выводиться в своём исходном состоянии.\n\r\nВ том, как всё это реализовано, есть одна примечательная деталь, которая заключается в том, что сведения о соотношении сторон изображения генерируются, что называется, «на лету», на основании параметров используемого изображения.\n\n\nВывод изображений с разным соотношением сторон\n\r\nБолее того, важно помнить о том, что Flexbox-макет не сжимает изображения до размеров, которые меньше минимальных размеров содержимого такого макета. То есть — если довести ширину окна браузера до определённого значения — Flex-элемент не станет меньше, чем минимальные размеры его содержимого. Для того чтобы это исправить, нужно свойство min-width: 0.\n\n\nМакет, который нуждается в доработке\n\r\nВ моём демонстрационном коде Flex-элемент является прямым потомком message__outer, в нашем случае это — message__row.\n\n.message__row {\n    min-width: 0;\n    /* другие стили */\n}\n\r\nВот как всё должно выглядеть в том случае, если всё работает так, как должно работать.\n\n\nДоработанный макет\n\r\nМожет, у кого-то возникнет мысль о том, что тут можно было бы дать изображению фиксированную ширину и воспользоваться встроенным CSS. Но надо понимать, что за каждым решением, даже небольшим, принятым разработчиками, стоит некая веская причина. Полагаю, что в данном случае всё дело в загружаемом изображении. Если бы не был задан фиксированный размер изображения — мы столкнулись бы со сдвигами макета.\n\nВывод нескольких изображений\r\nЕсли пользователь отправляет в чате сразу несколько изображений, соотношения их сторон не учитываются. Вместо этого каждое изображение размещается в квадратной области, а волшебное свойство object-fit позволяет не искажать и не растягивать изображения.\n\n\nВывод нескольких изображений\n\n.gallery {\n    display: flex;\n    flex-wrap: wrap;\n    flex: 1;\n    /* Отрицательное поле позволяет выровнять галерею с\n    элементами того же уровня. */\n    margin: -2px;\n}\n\n.gallery__item {\n    /* Добавить смещение размером 2px вокруг каждого изображения, что даст\n    4px для двух смежных изображений. */\n    padding: 2;\n}\n\n.gallery__item--third {\n    flex: 33.33%;\n}\n\n.gallery__item--half {\n    flex: 50%;\n}\n\r\nВот что здесь происходит:\n\n\nСетка для вывода изображений построена с использованием CSS Flexbox.\nШирина изображения составляет треть или половину ширины Flexbox-контейнера, что зависит от количества изображений.\nРасстояние между изображениями регулируется путём настройки полей родительских элементов изображений.\nЧтобы не оставлять ненужных пустых пространств вокруг границ галереи, во Flex-контейнере должно быть использовано отрицательное значение свойства padding.\n\r\nМне хотелось бы уделить особое внимание свойству padding: 2px, которое используется для настройки расстояния между изображениями. Оно не только позволяет добиться желаемого эффекта, но и отличается универсальностью, так как подходит для LTR- и RTL-макетов.\n\r\nЕсли вы хотите углубиться в тему настройки расстояния между элементами с помощью CSS — взгляните на эту мою статью.\n\nЦитирование сообщений\n\nПроцитированное сообщение и текст обычного сообщения\n\r\nПри выводе процитированного сообщения используются три основных элемента:\n\n\nЗаголовок, показывающий, кто кому ответил (например — «You replied to Ahmad»).\nПроцитированное сообщение, выведенное с использованием особого стиля.\nТекст сообщения.\n\r\nПрисмотримся к структуре процитированного сообщения.\n\r\nУстроено оно просто и понятно — блок такого сообщения очень похож на блок обычного сообщения, но у него нет дополнительных элементов вроде меню и области для вывода состояния сообщения.\n\r\nУ сообщения (выведено серым) установлено большое значение свойства padding-bottom и отрицательное значение margin-bottom, что позволяет переместить текст процитированного сообщения выше, чем текст обычного сообщения. И наконец — его правый нижний угол не скруглён.\n\n.message--washed {\n    border-bottom-right-radius: 0;\n    padding: 8px 12px 9px;\n    margin-bottom: -17px;\n}\n\r\nА вот — стиль для текста, где настраивается свойство padding-bottom.\n\n.message--washed__text {\n    padding-bottom: 12px;\n}\n\n\nПроцитированное сообщение\n\r\nТо же самое касается и цитат в виде изображений.\n\n\nПроцитированное сообщение с изображением\n\r\nТак же цитируются и вложения (вроде голосовых сообщений и видеозаписей).\n\n\nПроцитированное изображение с вложением\n\nРеакции\r\n«Реакция» это когда пользователь реагирует на сообщение, пользуясь эмотиконами. Эти «реакции» выводятся ниже сообщения. Вот пример.\n\n\n«Реакция», выведенная под сообщением\n\r\nВот HTML-код:\n\n<div class=\"message\">\n    <div class=\"message__outer\">\n        <div class=\"message__avatar\"></div>\n        <div class=\"message__inner\">\n            <div class=\"msg-bubble-wrapper\">\n                <div class=\"message__bubble\"></div>\n                <div class=\"reaction\">\n                    <div class=\"reaction__content\">\n                        <img src=\"assets/heart.png\" alt=\"\">\n                        <img src=\"assets/smile.png\" alt=\"\">\n                        <span class=\"count\">2</span>\n                    </div>\n                </div>\n            </div>\n            <div class=\"message__actions\"></div>\n            <div class=\"message__spacer\"></div>\n        </div>\n        <div class=\"message__status\"></div>\n    </div>\n</div>\n\r\nЭлемент, который накладывается на другой элемент, это — содержимое «реакции», а не родительский элемент.\n\r\nВот стили:\n\n.reaction__content {\n    display: flex;\n    align-items: center;\n    background-color: #fff;\n    border-radius: 10px;\n    padding: 1px 1px 1px 3px;\n    box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.1);\n    transform: translateY(-7px);\n}\n\r\nКроме того, для того чтобы расположить элементы там, где находится начало родительского элемента, нужно выровнять их по Flexbox родительского уровня. Тут речь идёт о LTR-макетах, а в RTL-макетах всё делается с точностью до наоборот.\n\n.msg-bubble-wrapper.with-reaction {\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n}\n\r\nЯ заметил, что для того чтобы аватар оставался бы выровненным по нижней части сообщения, используется элемент <div>, высота которого равняется 18px, играющий роль разделителя.\n\n\nРазмещение «реакций» в LTR и RTL-макетах\n\r\nВот разметка:\n\n<div class=\"message__status\">\n    <img src=\"avatar.jpg\" alt=\"\">\n    <div style=\"height: 18px;\"></div>\n</div>\n\r\nИли, если речь идёт о сообщении отправителя, используется следующая разметка.\n\n<div class=\"message__avatar\">\n    <img src=\"avatar.jpg\" alt=\"\">\n    <div style=\"height: 18px;\"></div>\n</div>\n\nРазметка списков сообщений\r\nРазметка, используемая для оформления списков сообщений — это интересная тема. Тут имеется элемент <div> с role=\"grid\" и с aria-label=\"Messages in conversation with Ahmad Shadeed\".\n\r\nВ этом контейнере находятся элементы-строки <div> с role=\"row\", а внутри каждого такого элемента имеется главный элемент с role=\"gridcell\".\n\r\nВот разметка, о которой идёт речь.\n\n<div class=\"mw_message_list\" role=\"grid\" aria-label=\"Messages in conversation with Ahmad Shadeed\">\n    <div role=\"row\">\n        <div role=\"gridcell\" tabindex=\"0\"></div>\n    </div>\n    <div role=\"row\">\n        <div role=\"gridcell\" tabindex=\"0\"></div>\n    </div>\n    <!-- other messages -->\n</div>\n\r\nНо это ещё не всё. В каждом сообщении имеется визуально скрытый элемент с текстом You sent или Person sent, в зависимости от того, кто отправил сообщение.\n\n<div role=\"row\">\n    <div role=\"gridcell\" tabindex=\"0\">\n        <h4 class=\"sr-only\">You sent</h4>\n        <!-- other elements -->\n    </div>\n</div>\n\r\nТут я обратил внимание на то, что одно из CSS-свойств, используемых для визуального скрытия текста — это clip-path: inset(50%).\n\r\nВот — полный код стилизации:\n\n.sr-only {\n    position: absolute;\n    height: 1px;\n    width: 1px;\n    overflow: hidden;\n    clip: rect(0px, 0px, 0px, 0px);\n    clip-path: inset(50%);\n}\n\nРасстояние между сообщениями\r\nТеперь, когда вы знаете о том, как выглядит разметка строк, в которых выводятся сообщения, поговорим о том, как настраивается расстояние между сообщениями. Делается это с помощью компонентов-разделителей, а не с помощью отступов или чего-то другого.\n\r\nКаждая строка с сообщением имеет элемент-разделитель высотой 2px или 7px, или, в некоторых случаях, и тот и другой. На следующем рисунке розовые элементы — это разделители высотой 7px, а жёлтые — это разделители высотой 2px.\n\n\nЭлементы-разделители\n\r\nКонтейнер верхнего уровня каждого сообщения — это Flex-контейнер с flex-direction: column.\n\r\nВот, например, изображение процитированного сообщения. Тут имеются разделители обоих видов. Кроме того, используемый здесь родительский элемент верхнего уровня — это Flexbox-контейнер с flex-direction: column.\n\n\nРазделители двух видов\n\nРазделители блоков сообщений, содержащие сведения о времени\r\nРазделитель блоков сообщений может содержать текст или сведения о времени. Тут я расскажу о тех, которые содержат сведения о времени.\n\r\nКогда пообщаешься с кем-то, а потом снова возвращаешься в чат — там можно заметить отцентрованный элемент со сведениями о дне недели и времени.\n\n\nРазделитель блоков сообщений\n\r\nДля создания подобных элементов используется довольно-таки интересная разметка.\n\n<h2><font color=\"#3AC1EF\">\n    <div class=\"sr-only\">October 28 at 6:12 PM</div>\n    <div aria-hidden=\"true\">Thu 6:12 PM</div>\n</font></h2>\n\r\nПервый элемент предназначен исключительно для средств чтения с экрана. Понять это можно благодаря классу sr-only (подсказка: дизайнеры Facebook пользуются вспомогательными классами, я добавил тут класс sr-only только ради понятности изложения). Второй элемент скрыт от средств для чтения с экрана, он предназначен для пользователя. Интересно — правда?\n\nПользовательская стилизация фона блоков сообщений\r\nХотя мне эта возможность мессенджера и кажется бесполезной, я всё же о ней расскажу. Пользователь может настроить фон блоков сообщений с использованием градиентных цветов.\n\n\nГрадиентные цвета блоков сообщений\n\r\nКогда пользователь прокручивает сообщения, всё выглядит так, будто их градиентная окраска анимирована.\n\n\nПрокрутка списка сообщений с градиентной окраской\n\r\nНа первый взгляд может показаться, что это делается с помощью JavaScript, что у каждого сообщения имеется особое фоновое изображение, которое меняет позицию при прокрутке списка. Но на самом деле всё не так. Это — чистый CSS. Сейчас я расскажу о том, как достигнут подобный эффект.\n\r\nГрадиент, который мы видели, устанавливается для фона элемента-контейнера, содержащего список сообщений. То есть — окрашивается весь тот белый фон на котором расположены сообщения. Взгляните на следующий рисунок.\n\n.messages-parent {\n    background-color: #3a12ff;\n    background-image: linear-gradient(#faaf00, #ff2e2e, #3a12ff);\n}\n\n\nГрадиентный фон\n\r\nСледующий шаг — убрать фоновый цвет и отключить скругление углов элементов, в которых выводятся сообщения (да, именно так всё и делается).\n\n\nНастройка элементов, в которых выводятся сообщения\n\r\nДалее — нужно задать белый фон буквально для всего, что имеется в интерфейсе — за исключением блоков, в которых выводятся сообщения (и это делается именно так).\n\n.message__actions,\n.message__status,\n.spacer-xs,\n.spacer-lg,\n.message__spacer,\n.message__avatar {\n    background-color: #fff;        \n}\n\n\nПродолжение работы над градиентным фоном\n\r\nМожет, эти рассуждения выглядят необычно. Я, чтобы доказать, что ничего не выдумал, привожу запись процесса исследования интерфейса Facebook Messenger.\n\n\nИсследование интерфейса\n\r\nОбратите внимание на то, что после того, как я включил градиентный фон, это повлияло на множество элементов. Все эти элементы, чтобы перекрыть градиент там, где его не должно быть видно, необходимо окрасить в белый цвет.\n\r\nТеперь, когда мы изолировали блоки сообщений, подумаем о том, как снова скруглить их углы. В этом деле нам помогут псевдоэлементы.\n\n.custom-theming .message__bubble {\n    position: relative;\n    border-radius: 0;\n    background: transparent;\n}\n\n.custom-theming .message__bubble::after {\n    content: \"\";\n    position: absolute;\n    left: -36px;\n    right: -36px;\n    top: -36px;\n    bottom: -36px;\n    border: 36px solid #fff;\n}\n\r\nЭтот ход позволяет нам выйти на следующий результат.\n\n\nПродолжение стилизации блоков сообщений\n\r\nТеперь нужно отредактировать углы. Как сделать внутренний закруглённый угол? Оказалось, что для этого можно воспользоваться следующей формулой:\n\nвнутренний радиус = border-radius - border-width\n\r\nТо есть — если даже добавить к вышеприведённым стилям border-radius: 36px, на угол это не повлияет. При использовании обычной стилизации, без градиента, свойство border-radius имеет значение 18px. Для того чтобы отразить это на внутреннем радиусе, нужно увеличить значение свойства border-radius псевдоэлемента.\n\nвнутренний радиус = = 54px - 36px = 18px\n\r\nВот отредактированные стили:\n\n.custom-theming .message__bubble {\n    position: relative;\n    border-radius: 0;\n    background: transparent;\n}\n\n.custom-theming .message__bubble::after {\n    content: \"\";\n    position: absolute;\n    left: -36px;\n    right: -36px;\n    top: -36px;\n    bottom: -36px;\n    border-radius: 54px;\n    border: 36px solid #fff;\n}\n\n\n\nСкруглённые углы\n\r\nИ наконец — нужно заключить псевдоэлемент в пределы элемента-обёртки блока сообщения.\n\n.custom-theming .message__bubble {\n    position: relative;\n    border-radius: 0;\n    background: transparent;\n    overflow: hidden;\n}\n\n\nОграничение псевдоэлемента рамками элемента-обёртки блока сообщения\n\r\nНаш последний шаг заключается в изменении цвета границы (свойства border-color) на белый, после чего всё будет сделано как нужно.\n\r\nЕсли вам интересно узнать о механизме анимации фона сообщений при прокрутке — знайте, что делается это посредством свойства background-attachment: fixed. И тут ещё используется граница элемента толщиной 2px белого цвета. Думаю, сделано так не без причины, а с прицелом на работу с пользовательским фоном.\n\n.messages-parent {\n    background-color: #3a12ff;\n    background-image: linear-gradient(#faaf00, #ff2e2e, #3a12ff);\n    background-attachment: fixed;\n    border-left: 2px solid #fff;\n    borfer-right: 2px solid #fff;\n}\n\nИтоги\r\nМне было интересно исследовать структуру блока сообщений Facebook Messenger. Мне очень понравился этот процесс. Вот мои основные выводы:\n\n\nCSS Flexbox — это лучшее, что случилось с дизайном интерфейсов.\nНе стоит судить о сложности разработки некоего компонента, глядя лишь на один из его вариантов.\nЧестно говоря — я не ожидал, что напишу об этом такую длинную статью. Когда я начал работу, я думал, что у меня получится небольшая заметка. Я ошибался — и мне это нравится.\nКомпромиссы — это неотъемлемая часть работы дизайнера. Например, всю пользовательскую стилизацию блоков сообщений можно реализовать с помощью JavaScript. Но команда разработчиков из Facebook решила сделать всё исключительно средствами CSS. Полагаю — из соображений производительности.\nПри работе над проектом, которым будут пользоваться жители разных стран, нужно учитывать то, что он должен поддерживать вывод текстов на разных языках, что эта возможность должна быть заложена в него с самого начала. Мне очень понравилось то, что Facebook Messenger — это именно такой проект, особенно учитывая то, что я написал руководство по RTL-стилизации.\n\r\n«Препарируете» ли вы интерфейсы известных веб-проектов в поиске интересных идей?\n\n",
        "user": "\n      ru_vds\n    ",
        "date": "27  июля  2015",
        "rating": " 2804.06 \n    Рейтинг\n  ",
        "hab": "Блог компании RUVDS.com Разработка веб-сайтов *CSS *Дизайн Социальные сети и сообщества ",
        "time": "сегодня в 17:00",
        "sait": "\n      ruvds.com\n    "
    },
    {
        "url": "https://habr.com/ru/company/neuronet/blog/589059/",
        "title": "ИИ  учится определять проблемы со здоровьем человека по звуку его голоса",
        "teg": "здоровьеголосиИ",
        "body": "Голосовые биомаркеры - специфические параметры голоса человека. После \"извлечения\" их можно проанализировать, выявив те либо иные проблемы со здоровьем того человека, чей голос изучали. Алгоритмы машинного обучения дают возможность значительно увеличить эффективность такого способа определения заболеваний. Давно уже известно, что изменения речи и ряда параметров голоса человека являются индикатором проблем со здоровьем. Речь идет о нейродегенеративных и легочных заболеваниях, сердечно-сосудистых расстройствах и проблемах с психикой. Пример - нарушение артикуляции или проблемы с произнесением гласных. В некоторых случаях эти признаки настолько явные, что их без труда может обнаружить и распознать специалист. В других сделать это без помощи технологий крайне сложно, если вообще возможно. Но голосовые биомаркеры и искусственный интеллект способны изменить эту ситуацию. Что касается самого понятия \"биомаркер\", то его Национальный институт здравоохранения США (NIH) определяет как \"характеристику, которая объективно измеряется и оценивается как индикатор нормальных биологических процессов. Либо же патогенных процессов или фармакологических реакций на терапевтическое вмешательство\". Так, биомаркеры крови являются индикатором рассеянного склероза. То же самое и с голосовыми биомаркерами - это такой же индикатор ряда заболеваний. Можно выделить две основные категории параметров голоса, которые имеют значение для анализа \"голосовых биомаркеров\". В частности, параметры акустические - частота, амплитуда, тон, высота голоса. Есть и просодические параметры - длина произносимых гласных, темп речи, продолжительность пауз.  Также можно использовать и некоторые лингвистические параметры.Все эти параметры могут быть связаны с различными показателями состояния организма человека. И точно так же, как искусственный интеллект может поставить диагноз, интерпретируя медицинские изображения, алгоритмы малинного обучения в состоянии идентифицировать и классифицировать отклонения в ходе интерпретации голосовых биомаркеров. Этот способ позволяет быстро ставить предварительный диагноз, который впоследствии уточняет врач. Достоинство методики еще и в том, что она позволяет ускорить процесс диагностирования, а ее стоимость минимальна. Многоступенчатый процесс анализа Процесс извлечения и определения голосовых биомаркеров состоит из нескольких этапов. Во-первых, необходимо выбрать тип записи в самом начале процесса. Это может быть вербальная, гласно-слоговая или невербальная вокализация. Во-вторых, нужно собрать аудиоданные - для этого пациентов просят зачитать текст, рассказать что-то о себе, произнести несколько гласных или просто покашлять. Аудиоданные записываются - по телефону или личном контакте с врачом. А затем анализируется. При этом программное обеспечение выполняет предварительную обработку звука, что включает в себя передискретизацию, уменьшение шума, кадрирование и т.п. Следующий шаг - определение звуковых характеристик, которые используются для обучения нейросети. По словам авторов идеи, чем точнее обучение, тем эффективнее будет действовать ИИ в дальнейшем. Так, проблемы с гласными звуками характерна для болезни Паркинсона, а вот спонтанная речь - это уже признаки болезни Альцгеймера и/или расстройств психики. И, конечно, COVID-19Было бы странно, если бы подобная работа не давала возможность диагностировать COVID-19 и оценивать последствия перенесенного заболевания для пациента. В 2020 году ученые из разных стран активно изучали возможность обнаружения и мониторинга выявленного заболевания. И голосовые биомаркеры - одна из возможностей выполнять такую работу эффективно, причем без посещения врача. Достаточно лишь аудиозаписи голоса пациента и/или кашля, чтобы система могла выявить (или нет) заболевание.Проект не является чем-то сверхсложным, да и сама идея лежит относительно на поверхности, поэтому занимаются реализацией ученые из разных университетов и стран, включая Кембридж, Институт здоровья Люксембурга, MIT и другие.В США представители MIT занимались обнаружением признаков болезни Альцгеймера по записи голоса пациента. Отработав технологию еще до наступления пандемии, они смогли применить свою технологию для детекции COVID-19 у пациентов. Для этого в единую систему объединили несколько нейронных сетей.Определение депрессии по голосу? Конечно!Как говорится, не ковидом единым. Представители научно-исследовательских организаций разных стран давно занимаются изучением влияния депрессии на коммуникационные способности человека, включая речь. Стоит отметить, что диагностирование депрессии и более серьезных проблем с психикой - сложная задача даже для профессионала. По данным “The Lancet”, правильный диагноз ставят лишь в 47,3% случаев.Для того, чтобы решить эту проблему, компания Sonde Health разработала технологи, которая позволяет определить депрессию по образцу голоса пациента. Для этого нужен лишь смартфон и приложение. У пациентов, которые страдают депрессией, наблюдаются четкие признаки этой проблемы, и это как раз голосовые маркеры. Более того, ряд симптомов депрессии, особенно у пожилых людей, является ранним признаком нейродегенеративных патологий. Телемедицина набирает ход Проникновение ИИ-технологий в медицину стимулирует развитие удаленной диагностики - когда пациенту не нужно идти в поликлинику для проверки состояния своего организма. Правда, пока что технологии, связанные с этим направлением, лишь развиваются, но можно ожидать, что в ближайшие несколько лет телемедицина станет вполне самостоятельной отраслью в здравоохранении. Этому помогает повсеместное распространение интернета, мобильных устройств и разработка специализированных приложений и сервисов. ",
        "user": "\n      neuroonet\n    ",
        "date": "1  июля  2017",
        "rating": " 72.28 \n    Рейтинг\n  ",
        "hab": "Блог компании Neuro.net Искусственный интеллект Здоровье Будущее здесь ",
        "time": "сегодня в 16:04",
        "sait": "\n      neuro.net\n    "
    },
    {
        "url": "https://habr.com/ru/company/productivity_inside/blog/589055/",
        "title": "Дайджест интересных материалов для мобильного разработчика #419 (8 — 14 ноября)",
        "teg": "маркетингuixдайджест разработчикааналитика",
        "body": "В нашей новой подборке работа с ATT в iOS и главный циклы в Android, конкуренция за память и данные акселерометра, которые могут многое рассказать, джентльменские релизы, самые зарабатывающие и популярные приложения и многое другое!\n\n\n\nЭтот дайджест доступен в виде еженедельной рассылки. А ежедневно новости мы рассылаем в Telegram-канале.\n\n iOS\n\r\n• Как добавить обязательный запрос на IDFA через App Tracking Transparency\r\n• Интервью с iOS-разработчиком\r\n• Как мы перестали плодить шаблонный код при работе с табличными представлениями в iOS\r\n• Как использовать GitHub Copilot со Swift, используя Visual Studio Code\r\n• Акторы Swift под капотом\r\n• Quick, Nimble. На несколько тестов больше\r\n• Тренды iOS: на что обратить внимание разработчику\r\n• Онлайн-собеседование: Senior iOS Developer Виталий Кузьменко\r\n• Apple должна будет разрешить ссылки на стороннюю оплату до 9 декабря\r\n• Приложения для iPhone могут многое рассказать о вас с помощью акселерометра\r\n• В этом году Apple не будет закрывать App Store на «новогодние каникулы»\r\n•  Тесты M1 Pro и M1 Max в сборке и тестировании в Xcode\r\n•  Понимаем то, как и когда SwiftUI решает перерисовать представления\r\n•  Что такое Deprecated API в iOS?\r\n•  Как решить любую проблему, связанную со сбоем iOS-приложения\r\n•  Как писать на SwiftUI с помощью Test-Driven разработки\r\n•  SwiftUI HStack: внимательный взгляд\r\n•  Играем со StoreKit 2 в iOS 15\r\n•  Делаем UI-тестирование возможным с TYGenerator\r\n•  Retain циклы и управление памятью в Swift\r\n•  12 советов, как сделать в Swift меньше кода\r\n•  Управление Safe Area в SwiftUI\r\n•  Управление фокусом в списках SwiftUI\r\n•  Показываем бейджи в SwiftUI\r\n•  iOS + MVVM\r\n•  ReCaptcha: невидимая ReCaptcha v2 для iOS\r\n•  Rugby: кеширование CocoaPods\n\n Android\n\r\n• Main Loop (Главный цикл) в Android Часть 1. Пишем свой цикл\r\n• Реверс уязвимого приложения от Delivery Club: результаты конкурса\r\n• Активная конкуренция за RAM в Android\r\n• Использование Jetpack Compose в продакшне: первые впечатления\r\n• Custom view на Compose\r\n• Как устроен финтех в Яндексе\r\n• Telegram объявляет новый конкурс для разработчиков под Android\r\n•  Jetpack Compose: основы модификаторов\r\n•  Обеспечение возможности сохранения состояния Android-приложения\r\n•  Разрешения Android: может быть проще?\r\n•  Автоматическое форматирование кода в Android Studio/Intellij IDEA\r\n•  Моделирование экранов Android как состояний\r\n•  Мы перенесли наше приложение Jetpack Compose на Material Design 3 и Material You\r\n•  Stateful Data в Android с sealed классами и Kotlin Flow\r\n•  Баг, который стоил мне полдня отладки в Android Studio\r\n•  Как мы сократили время сборки Gradle более чем на 80%\r\n•  ExpandableText в Jetpack Compose\r\n•  REST API с Ktor в Android\r\n•  Android: простая реализация MVI с помощью Jetpack Compose\r\n•  Делаем просто темный режим с Jetpack Compose и Material Design 3\r\n•  Обработка исключений в Kotlin Coroutines\r\n•  Здравствуйте, мои сборки Gradle медленные!\r\n•  Приключение GoDaddy Studio с Управлением Состояниями и MVI/однонаправленным потоком данных на Android\r\n•  ByteLegend: обучение программированию в игре\r\n•  PasswordValidationView: наглядная проверка пароля\r\n•  TFProfiler: профайлер нейронных моделей\n\n Разработка\n\r\n• Computer Vision для iOS, Android, Web\r\n• Разновидности «игровых» багов\r\n• Как запилить джентльменский релиз\r\n• Генерация TeleportArea с помощью NavMesh\r\n• Как разработчику просить о повышении зарплаты\r\n• Про Flutter: как бекендер в мобильную кроссплатформу лез\r\n• «Сам ты ворованный!», или Что iPhone и Android позаимствовали друг у друга\r\n• Поиграть в игру = протестировать игру. Почему это утверждение неверно?\r\n• Шейдеры в Unity — это не сложно. Часть 2 — диффузный шейдинг\r\n• Podlodka #240: Golang\r\n• Podlodka #241: профессия: бизнес-аналитик\r\n• Дизайн приложений: примеры для вдохновения #63\r\n• Задачи с собеседований: офис\r\n• Что нового в Firebase: расширения для eCommerce и поддержка tvOS и macOS\r\n• Daily встраивает виде и аудио звонки в продукты\r\n• Т1 Консалтинг проведет хакатон по созданию корпоративных сервисов\r\n• Constructor упрощает управление проектами\r\n• Niantic запускает AR-платформу Lightship для всех разработчиков\r\n• Дизайн – не искусство, а UX – не дизайн\r\n• Дизайн, направленный на удержание пользователей. Разбираем метод “Настольной игры”\r\n•  10 расширений VS Code для борьбы с техническим долгом\r\n•  Пример UX: разработка приложения для доставки еды\r\n•  Как масштабировать ваши приложения\r\n•  Использование SwiftUI и Compose для разработки виджетов приложений на iOS и Android\r\n•  Вышла Visual Studio 2022\r\n•  Смерть от кода — когда разработчики проигрывают борьбу со сложностью\r\n•  Перестаньте требовать определенного опыта от Senior-инженеров\r\n•  Советы по оптимизации Flutter\r\n•  Защита приложений Flutter\r\n•  Предупреждения компилятора — это плохо\r\n•  Закон Грешема: почему плохие разработчики вытесняют хороших, а разработчики создают некачественный код\n\n Аналитика, маркетинг и монетизация\n\r\n• Puls: ремонт по запросу\r\n• Com2uS: история успеха UA-кампании в ведущих китайских медиа\r\n• ЧТО ПО ASO: обзор Asodesk\r\n• Объем российского рынка видеоигр в 2021 составит 165,6 млрд рублей\r\n• Google перенес электрический Ford F-150 в дополненную реальность\r\n• Самые зарабатывающие приложения октября в США\r\n• MyTracker бесплатно атрибуцирует Facebook для Android-приложений\r\n• Софт лонч: самые важные шаги для подготовки и тестового запуска приложения. Видеоинструкция от AppFollow.\r\n• AudioMob привлекает еще $14 млн на аудиорекламу в играх\r\n• Unity покупает студию эффектов Weta Digital Питера Джексона\r\n• Roblox потерял $6.5 млн от сбоя\r\n• Самые популярные приложения в октябре 2021\r\n• Требования для публикации приложений в AppStore и Google Play в 2021\r\n• 11 лайфхаков по продвижению мобильных приложений и игр на «Чёрную пятницу» от AliExpress, OZON, Subway Surf, Hero Wars\r\n• 10 ошибок в A/B-тестировании мобильных приложений\n\n AI, Устройства, IoT\n\r\n• Нейросеть, способная объяснить себе задачу: P-tuning для YaLM\r\n• Google научился искать двойников домашних питомцев в произведениях искусства\r\n• На что влияет Big Datа и может ли она кого-нибудь уволить\r\n• H2O.ai получает $100M на ИИ для предприятий\r\n•  11 алгоритмов машинного обучения, которые вы должны знать в 2021 году\n\r\n← Предыдущий дайджест. Если у вас есть другие интересные материалы или вы нашли ошибку — пришлите, пожалуйста, в почту.",
        "user": "\n      ProductivityInside\n    ",
        "date": "10  апреля  2009",
        "rating": " 108.92 \n    Рейтинг\n  ",
        "hab": "Блог компании Productivity Inside Разработка под iOS *Разработка мобильных приложений *Разработка под Android *",
        "time": "сегодня в 15:52",
        "sait": "\n      productivityinside.com\n    "
    },
    {
        "url": "https://habr.com/ru/company/ruvds/blog/586394/",
        "title": "Printf(\"%s %s\", внедрение, зависимостей)",
        "teg": "разработкаruvds_переводPrintf",
        "body": "Механизм внедрения зависимостей (Dependency Injection, DI) стал одним из тех аспектов корпоративного программирования, с которыми мне было сложнее всего разобраться. А именно, дело было в том, что это понятие уже имело для меня смысл. Мне, для того, чтобы этот смысл увидеть, не пришлось много всего читать.\n\n\n\r\nВ функциональном программировании смысл DI заключается в передаче функциям других функций.\n\r\nВот — пример функции (Erlang):\n\n-module(example).\n-export(add_one/1).\n\nadd_one(N) -> N + 1\n\r\nРаботает она очень просто: получает число и прибавляет к нему единицу.\n\r\nВнедрим эту зависимость в функцию, которая перебирает список чисел и применяет переданную ей функцию к каждому из его элементов:\n\nEshell V12.0  (abort with ^G)\n\n1> c(examples).\n{ok,examples}\n\n2> lists:map(examples:add_one, [0, 1, 2, 3]).\n[1, 2, 3, 4]\n\r\nЗамечательно! Конструкция lists:map проходится по списку и применяет к каждому числу из списка функцию add_one.\n\r\nА как насчёт Lisp?\n\n* (DEFINE ADD-ONE (N) (+ N 1))\nADD-ONE\n\n* (MAPCAR #'ADD-ONE '(0 1 2 3))\n(1 2 3 4)\n\r\nРаботает! А JavaScript?\n\n> const addOne = n => n + 1\nundefined\n\n> [0, 1, 2, 3].map(addOne)\n(4) [1, 2, 3, 4]\n\r\nПрекрасно!\n\r\nТеперь нам остаётся лишь переименовать map в fmap, притворившись, что мы понимаем, что такое «моноидная операция». И вот — мы уже стали Haskell-программистами.\n\r\nЕсли говорить о Haskell, то можно сказать, что благодаря усилиям замечательных разработчиков GHC (Glasgow Haskell Compiler), компилятора языка Haskell из Глазго, это было реализовано в .NET, в форме Language Integrated Query (LINQ):\n\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic static int AddOne(int n) => n + 1;\n\nnew List<int>(){0, 1, 2, 3}\n    .Select(AddOne); // [1, 2, 3, 4]\n\r\nСоответствующий метод назвали Select для того чтобы никто ничего не заподозрил, намекая на то, что это — всего лишь типизированный язык SQL, а не функциональное программирование. Хитрецы.\n\r\nИтак, всякий раз, когда я слышал о DI, я думал, что всё то, о чём я рассказал, и есть внедрение зависимостей. Но, как оказалось, это не так.\n\nГотовьтесь! Сейчас начнётся!\npublic interface IGetAThing\n{\n    IThing GetThing();\n}\n\npublic MyThingGetter : IGetAThing\n{\n    private readonly IThingFactory _factory;\n\n    public MyThingGetter(IThingFactory factory) \n    {\n        _factory = factory;\n    }\n\n    public IThing GetThing()\n    {\n        return _factory.Get(thing.NORMAL);\n    }\n}\n\npublic MyApi\n{\n    private readonly IGetAThing _myThingGetter;\n\n    public MyApi(IGetAThing thing)\n    {\n        _myThingGetter = thing;\n    }\n\n    public IThing GetThing()\n    {\n        return _myThingGetter.GetThing();\n    }\n}\n\r\nА это, да простит нас Алан Кэй, что ещё такое?\n\r\nЯ понимаю, что выглядит это несколько несерьёзно, но то, что можно счесть недоработками, появилось тут лишь из-за того, что я стремился сделать этот пример как можно короче. Нормальный код занял бы столько же места, сколько занимает вся эта статья.\n\r\nВот что можно сказать в пользу такого стиля программирования:\n\n\nКаждая зависимость внедрена в код (за исключением перечисления).\nМы успешно разделили программу на аккуратные SOLID-блоки.\nMyAPI даёт интерфейс, рассчитанный на определённого пользователя этого интерфейса, не предоставляя сведений о внутренней реализации интерфейса.\nMyThingGetter даёт интерфейс для получения объекта Thing, но делегирует выполнение этой операции сущности Factory, которая подключается к программе во время её выполнения.\nFactory принимает элемент перечисления, что позволяет предотвратить ошибки, связанные с «магическими» строками.\nЛюбой слой программы можно заменить, не трогая при этом слои, находящиеся выше или ниже его.\n\r\nВ этом есть что-то волшебное, черпающее свою силу из глубин нашей программы:\n\nstatic IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .ConfigureServices((_, services) =>\n                    services.AddHostedService<Program>()\n                            .AddScoped<IThingFactory, ThingFactory>()\n                            .AddScoped<IGetAThing, MyThingGetter>());\n\r\nЯ, чтобы никого не перегружать ненужным чтением, опустил тут XML-код.\n\nДостоинства\n\nЧёткое разделение слоёв абстракции.\nЗаменяемые, благодаря паттерну Стратегия, компоненты.\nПри таком подходе редактировать существующий код нужно не так часто, как при использовании других подходов.\n\nНедостатки\n\nСмерть от тысяч классов.\nРаздолье для сборщика мусора.\nНеобходимость тестирования монструозных конструкций.\nЦарство существительных.\n«Никто больше не покупает молотки».\n\r\nРазобраться с каждым отдельным компонентом может быть и несложно, но — ценой необходимости постоянно просматривать код и добавлять реализацию в место, предшествующее ему. Это — как если взять Lisp-код, помещающийся на одном экране, и разбросать его по нескольким файлам.\n\r\nВ деле исследования и написания кода вам поможет ваш новый лучший друг — команда Перейти к определению (F12), а вот тестирование — это то, в чём у вас помощников не будет. Задача усложняется.\n\nIMyThingGetter _myThingGetter;\n\npublic static void TearMeUp()\n{\n    _myThingGetter = new Mock<MyThingGetter>().When(MyThing.GetThing).Do((ThingType t) => { \n        t == thing.NORMAL ? new Thing() : throw new ArgumentExceptionError();\n    }\n}\n\n[MakeThisTestRunPlease(true)]\npublic static void Test_MyThingGetter_Should_GetAThing_When_WeWantTo()\n{\n    // Приведи в порядок.\n    TearMeUp();\n\n    // Действуй.\n    var thing = _myThingGetter.GetThing(thing.NORMAL);\n\n    // Купи мою книгу.\n    assert.Equal(thing, new Thing());\n\n    WakeMeUpInside();\n}\n\npublic static void WakeMeUpInside()\n{\n    _myThingGetter = null;\n}\n\nКакое это имеет отношение к внедрению зависимостей?\r\nПолагаю, что это не особо сильно связано с внедрением зависимостей.\n\r\nУ меня такое ощущение, что, решая пользоваться подобным внедрением зависимостей в корпоративной разработке, мы получаем не только банан, который был нам нужен, но ещё и гориллу, которая держит этот банан, а заодно и все джунгли. А раз уж речь зашла о бананах, то недалеко и до ядовитых лягушек-древолазов.\n\r\nНет ничего опасного в том, чтобы вручную создавать необходимую инфраструктуру:\n\nlogger := log.New(log.DefaultConfig{})\n\ndbConfig := db.NewConfig{\n    Logger: logger,\n}\n\ndb := db.New(dbConfig)\n\nmyApi := &myApi{\n    Logger: logger,\n    DB: db,\n}\n\r\nТакой код легко читать, его легко писать и понимать. В нём не нужны зависимости. Если нужно в него что-то добавить — делается это прямо в нём самом. Не нужно ничего регистрировать, не нужно использовать XML-файлы. Это — просто код. Ваш код.\n\r\nЕсли вам необходимо более абстрактное внедрение зависимостей, в этом деле вам поможет совершенно замечательный инструмент — интерфейсы. У передачи Reader структуре в виде зависимости могут найтись варианты применения, но прямая передача Reader функции создаст вам гораздо меньше проблем, особенно — при тестировании.\n\r\nЕсли вам повезло, и вы пишете код в функциональном стиле, то передача функций другим функциям делается ещё проще. Иногда благодаря этому в нашем распоряжении оказываются замечательные механизмы обеспечения безопасности во время компиляции кода.\n\r\nПрименяйте композицию для создания более продвинутых функций. Пусть данные будут данными.\n\r\nИ передавайте своим функциям какие-нибудь значения!\n\n\nМне нравится применять внедрение зависимостей (передавать функциям значения)\n\r\nКак вы относитесь к внедрению зависимостей?\n\n",
        "user": "\n      ru_vds\n    ",
        "date": "27  июля  2015",
        "rating": " 2804.06 \n    Рейтинг\n  ",
        "hab": "Блог компании RUVDS.com Программирование *",
        "time": "сегодня в 13:00",
        "sait": "\n      ruvds.com\n    "
    },
    {
        "url": "https://habr.com/ru/company/servermall/blog/588348/",
        "title": "Доэлектрический счёт: от пальцев к арифмометрам",
        "teg": "Арифмометрретрокомпьютингвычисленияистория itкалькуляторсчетустройствадевайс",
        "body": "У современного человека есть потрясающие инструменты для работы с числами: смартфоны, планшеты, калькулятора, компьютеры и т.д. Калькуляторы (как отдельные устройства) считаются архаизмом и используются редко, например, в офисах и образовательных учреждениях. Для большинства людей калькулятор – это иконка в дальней папке телефона, про которую вспоминают, когда надо посчитать зарплату или разделить счёт в ресторане.Однако пару сотен лет назад за современный калькулятор могла бы развернуться настоящая война. Тем не менее людям нужно было считать задолго до их появления.Калькулятор диванных войск.В журнале Nature Communications опубликована статья, в которой исследователи из США выяснили, что обезьяны интуитивно понимают числа и способны различать количество объектов независимо от их размеров.Поэтому напрашивается вывод, что люди считали ещё в те времена, когда не знали, что такое счёт или изопериметрические неравенства в математической физике.Трагедия, драма в одном акте.Но уж если человек берётся за какое-то дело, то всегда ищет способы его оптимизировать: ускорить, потратить меньше ресурсов, сделать качественнее и точнее. Так появились первые инструменты счёта.История инструментов счётаСодержание:Счёт на пальцах;Простейшие устройства:Балансирные весы;Абак.Сложные устройства:Палочки непера;Логарифмическая линейка;Арифмометры:Считающие весы Вильгельма Шиккарда;Паскалина;Калькулятор Лейбница;Суммирующая машина Якобсона;Арифмометр Шарля де Кольмара;Вычислительная машина Штаффеля;Арифмометр Однера.Наследие.Чем богаты, тем и радыПервый инструмент лежал буквально перед глазами. Настолько буквально, что это наши руки :)Если повторить за картинкой, то может пойти дождь.Счёт на пальцах оставался широко распространённым в древнем мире вплоть до конца средневековья. С развитием торговли людям понадобилось считать бóльшее количество объектов, тогда появилась, возможно, первая разрядность: 5 – “одна рука”, 10 – “две руки”, 20 – “один человек”. Таким образом древние народности научились считать вещи в “людях”. К пальцам “одного человека” можно прибавить пальцы “второго”, “третьего” и т.д.Цивилизация индейцев майя называла данную систему счисления двадцатичной. Вероятно, количество пальцев на руках подарило нам десятичную систему счисления.Все народы на этапах своего становления так или иначе вели простейшие математические операции, поэтому появилось огромное разнообразие способов счёта на пальцах.Современный специалист счёта на пальцах (пальцев).Как пример, рассмотрим ситуацию, когда возникает недопонимание у людей разных национальностей.Английский счётВ большинстве англоязычных стран люди ведут счёт разжатием пальцев из кулака, где пятерка соответствует большому пальцу. Прямо как у нас, японцев и людей из балканского региона на юго-востоке Европы.Три по-английски.В фильме Квентина Тарантино “Бесславные ублюдки” обыгрывается разница между счётом у англичан и немцев. Когда в баре британский военный (играет Майкл Фассбендер) под прикрытием заказывает выпивку и показывает указательным, средним и безымянным пальцами число три, другой военный – офицер фашистской Германии (Аугуст Диль) – сразу же раскрывает его. После начинается перестрелка в лучших традициях Тарантино.Отсюда вопрос: как заказать виски в Германии, чтобы не попасть в перестрелку?Континентальный европейский счётИменно этот счёт используют немцы, французы и другие народы континентальной западной Европы.Три по-немецки.Принцип следующий:Счёт начинается с большого пальца и указывает на число 1.Разгибаем указательный (число 2) и т.д. до мизинца (число 5).На другой руке продолжаем считать аналогично – большой палец соответствует шестерке.Иногда используется (во Франции и других странах Европы) альтернативный способ, при котором пальцы не разгибают, а загибают.Простейшие устройстваТысячи лет назад человечество освоило простейшие счётные устройства. Торговля и хитрость людей (ага, уже тогда пытались продать два бивня мамонта по цене трёх) способствовали созданию инструментов счёта.Балансирные весыБалансирные весы вашего детства.Стоп, стоп, стоп. Да, весы не позволяют пересчитывать вещи по отдельности, однако торговцам древности не требовалось знать точное количество зёрнышек риса в мешке, достаточно было определить эквивалент этого мешка. И балансирные весы справлялись с этой задачей просто замечательно. Привычные нам весы считаются одним из первых приборов для количественного определения массы.Абак – семейство счётных досокВ ряде древних культур для арифметических вычислений использовались счётные доски. Как и откуда появился абак – неизвестно, однако, учитывая большое распространение в мире, этот инструмент мог появиться в некой родительской народности, “породившей” все остальные.В современном мире по-прежнему применяются некоторые варианты абака – русские счёты и японский соробан. В некоторых странах счёты всё ещё в ходу: используются в работе и обучении детей, так как аналоговые приборы надёжны, а их удобство проверено временем.У вас тоже олдскулы свело?Сложные устройстваПервые сложные счётные устройства появились в античности вместе с зубчатыми колёсами. Узнать, какой механизм был первым, когда он был произведён – невозможно. Однако в 1901 году на борту затонувшего корабля нашли Антикитерский механизм. Учёные установили, что он был создан приблизительно во II веке до н.э.Механизм использовался для расчёта движения небесных тел и позволял узнать дату 42 астрономических событий.Особенности: Механизм представляет собой календарь, а также астрономическое, метеорологическое, образовательное и картографическое устройство;Технология создания была утеряна;Самый древний образец аналогового вычислительного устройства;Первая известная механическая Солнечная система, планетарий и астрономические часы.Потребность в функциональных устройствах имелась всегда, поэтому, несмотря на утерю технологии создания Антикитерских механизмов, люди придумывали другие. Рост сложности расчётов в XVII веке привел к новым изобретениям.Палочки Непера – быстро забытый восторгСоздал Палочки Непера шотландский математик и отец логарифмов – Джон Непер (1550-1617). Принцип работы изобретения описан в его книге 1617 года.Особенности:В основном использовались для сложных действий умножения, реже – деления;Непер также является одним из изобретателей логарифмов;Такой инструмент легко сделать самому из обычного листа бумаги, когда использовать калькулятор нет возможности или запрещено (например, на экзамене).Принцип работы в двух словахЕсли вкратце, то инструмент создан для умножения и состоит из 10 длинных прямоугольных палочек. На каждой грани записано число, а ниже – результат его умножения на 1,2,3 и т.д до 9.Палочка Непера. Попрошу без смешков. 61/21/82/43/03/64/24/85/4С помощью нескольких палочек можно было умножить большое число, например, 6359 на 5:Выбираем палочки с этими числами сверху и прикладываем друг к другу;Пятые квадраты дадут произведение числа на 5;Складываем эти произведения.63591/20/61/01/81/80/91/52/72/41/22/03/63/01\\52/54/53/61/83/05/44/22/13/56/34/82/44/07/25/42/74/59/13 (0 + 1) (5 + 2) (5 + 4) 5 Итого получаем: 31795Когда Палочки Непера только появились, они пользовались большой популярностью, однако совсем скоро на смену им пришел более совершенный инструмент счёта.Логарифмическая линейкаПервые попытки создать нечто похожее на логарифмическую линейку, предпринял в XVII веке Эдмунд Гюнтер – астроном из Англиии. Он нанёс на классическую линейку шкалу логарифмов и с помощью двух циркулей производил расчёты. Это было сложно, долго и требовало повышенной внимательности.Классическая линейкаПараллельно Гюнтеру логарифмическую линейку разрабатывал Уильям Отред (1575-1660), который предложил вместо циркулей две одинаковые шкалы, скользящие вдоль друг друга. Спустя пару лет после смерти Отреда линейку оснастили бегунком и визиром. В таком виде она служит людям и по сей день.Появление логарифмической линейки было важным событием того времени, так как она давала возможность быстро складывать, вычитать, умножать, делить, возводить в степень, извлекать корень, катапультировать бумажки в других учёных, вычислять логарифмы и работать с тригонометрическими функциями.Особенности:До появления карманных калькуляторов этот инструмент служил незаменимым расчётным орудием инженеров и математиков;Высокая точность расчётов – около 3 значащих цифр;Огромный функционал;Компактность;Невысокая цена.Каждый хоть раз в жизни видел или держал логарифмическую линейку в руках. На её устройстве и принципе работы останавливаться не будем, так как существует очень много видов линеек с разным функционалом и формой. Для некоторых моделей даже выпускали целые книги-инструкции. Тем, кто желает углубиться или освежить память, оставлю ссылку на подробный материал.Зачитанная до дыр инструкция для тех, кто любит поподробнее. Следующим этапом в развитии счётных инструментов стали сложнейшие механические устройства.Эпоха арифмометровАрифмометр – это механическая счётная машина, созданная для математических вычислений. Первые образцы появились ещё в XVII веке, однако есть мнение что Леонардо да Винчи в своих дневниках изобразил первый арифмометр еще в 1492 г.Леонардо да Винчи изобретает всё, что у нас есть сегодня. Фото сделано также на фотоаппарат его разработки (нет).Доказательств, что на его чертежах был именно механизм счётной машины, а также, что она была создана, не сохранилось. Поэтому сразу перейдём к настоящим арифмометрам.Считающие часы Вильгельма Шиккарда – нейминг придумали позжеПро это устройство есть отдельная подробная статья на Хабре, желающих – милости прошу. Считающие часы Вильгельма Шиккарда – первый механизм, способный  складывать, вычитать, делить и умножать. До наших дней дошло немного информации о нём, однако известно, что над изобретением в 1623 году трудился немецкий учёный, астроном и математик – Вильгельм Шиккард  (1592-1635).Особенности:Первая в мире механическая счётная машина, позволяющая складывать, вычитать, делить и умножать числа; Была известна довольно узкому кругу лиц, и поэтому долгое время (почти 300 лет со дня её изобретения) никто не знал о её существовании.Работа механизма была основана на использовании взаимосвязанных звёздочек и шестерёнок, из-за конструктивного сходства с часами устройство и получило название “считающие часы”. Друг Шиккарда, философ и астроном Иоганн Кеплер, в письмах получал информацию о практически готовом устройстве, которое впоследствии сгорело в пожаре. Звучит правдоподобно.Доподлинно неизвестно, была ли создана вторая версия устройства. Вероятно, никто, кроме самого Шиккарда и его механика Вильгельма Пфистера, работающее устройство так и не увидел.Из-за этих обстоятельств долгое время первым арифмометром считалось изобретение другого учёного.ПаскалинаПаскалина – это механическое складывающее устройство, напоминающее ящик со связанными друг с другом шестёренками.В 1640 году некий одарённый 17-летний юноша в Руане помогал отцу распределять подати, налоги и пошлины. Наблюдая за бесконечными и невероятно утомительными расчётами отца, работавшего председателем налогового управления, он задумал создать устройство, способное помочь в неудобных традиционных расчетах. Спустя два года он создаёт свою суммирующую машину – Паскалину. Имя того юноши – Блез Паскаль (1623-1662). Впоследствии он стал классиком французской литературы, одним из основателей математического анализа, теории вероятностей и проективной геометрии.Особенности:Первый арифмометр, получивший известность ещё при жизни автора;Основное назначение – сложение;Умножение в устройстве выполняется в виде многократного сложения, для деления числа нужно было использовать многократное вычитание.Принцип работыПо-умолчанию машина складывает введённые поворотными деталями числа. Каждая деталь соответствует десятичному разряду числа и пронумерована от 0 до 9. Чтобы ввести число, нужно было повернуть колёсико до соответствующей цифры. При полном обороте колёсико переносило избыток на соседний разряд, сдвигая соседнюю деталь на 1 позицию. Ответ выводился в окошке сверху.При желании Паскалина позволяла не только складывать, но и выполнять другие операции, но в таком случае требовалась сложная процедура последовательных сложений и вычитаний.Изобретение Паскаля вызывало восторг у людей того времени, однако за 10 лет учёный сумел собрать лишь 50 “Паскалин” и продать с дюжину из них. Богатства изобретение ему не принесло, так как стоимость и сложность создания были слишком высоки, а вычислительные способности ограничены.Калькулятор ЛейбницаТакой в карман не положишь.Калькулятор Лейбница – это счётная машина созданная  в 1673 году немецким математиком Готфридом Вильгельмом Лейбницем (1646-1716). Это первое устройство, способное умножать и делить также легко, как складывать и вычитать.Кстати, про Лейбница есть замечательный лонгрид на Хабре. Предпосылкой к созданию этого арифмометра послужило знакомство с астрономом Христианом Гюйгенсом. Как Паскаль желал упростить расчёты отца, так и Лейбниц намеревался помочь Гюйгенсу (и себе, разумеется) упростить и ускорить астрономические вычисления.От идей и набросков до первого прототипа прошло 3 года. Калькулятор впервые “вышел” в свет на заседании Лондонского Королевского общества. Сын маминой подруги в мире арифмометров – не иначе. Последующие несколько лет Лейбниц дорабатывал конструкцию и уже в 1676 году представил в Лондоне предрелизный новый вариант. Лейбниц в Лондоне, 1676 год.Но, как это часто бывает с прототипами, калькулятор не годился для реального применения из-за малой разрядности, а на последующую доработку ушло еще 18 лет. Последний вариант был создан в 1710 году – спустя 40 лет от первой идеи.Особенности:Идея ступенчатого валика оказалась весьма плодотворной. Вплоть до конца XIX века конструкция валика совершенствовалась и развивалась различными изобретателями механических машин;Де-факто, это первый арифмометр, предназначенный для выполнения четырёх арифметических действий, позволяющая использовать 8-разрядное множимое и 9-разрядный множитель с получением 16-разрядного произведения;Не стал популярным по двум причинам: отсутствие на него устойчивого спроса и конструкционной неточности, влияющей на результат при умножении предельных для него чисел.Суммирующая машина ЯкобсонаСуммирующая машина Якобсона – это, вероятно, первая отечественная счётная машина, созданная Евной Якобсоном. Ни документов, ни свидетельств о времени изготовления машины найдено не было, однако удалось установить промежуток благодаря некоторым надписям на корпусе устройства:Mechanische Rechnungs Mashine (нем. Механическая счетная машина);Mechina Mechaniszna do Rachunku (польск. Механическая счетная машина);Zu der Aufgabe des Addirens, Subtantirens, Multiplicirens, und Devidirens von den Nummer Eins biz kann man hier in der Bruchen zertheilen (нем. Для задачи сложения, вычитания, умножения и деления от числа один до тысячи миллионов, и остающееся от деления можно здесь же расчленить на дроби);Erfunden und verfertigen von dem Hebreer Jawna Jacobson, Uhrmacher und Mechanicis in der Stadt Nieswiez in Lithauen, Gouvernement Minsk (нем. Изобретена и изготовлена Евной Якобсоном, часовым мастером и механиком, в городе Несвиже Литвы, Минское воеводство).В последней надписи указан город Несвиж, который входил в состав Минского воеводства до 1793 года. Таким образом Суммирующая машина Якобсона была создана не позднее этой даты.Из особенностей машины можно выделить следующее:Основные механизмы установлены во внутренней части машины, а на наружной крышке находятся все шкалы и элементы для управления;Высокая надежность и удобство в управлении, а размещение зубчатых колёс в несколько уровней делало его ещё и компактным;Внимание к деталям. Доходило до того, что каждая деталь одного разряда была отмечена одинаковым знаком, чтобы при ремонте детали не перепутались;Совокупность удачных и находчивых решений делает эту машину выдающейся для своего времени.Арифмометр Шарля де КольмараШарль Ксавье Тома де Кольмар (1785-1870) – французский бизнесмен и изобретатель первого в мире коммерческого арифмометра. Принцип работы его изобретения был основан на калькуляторе Лейбница с дальнейшим развитием идеи ступенчатого валика. В 1820 году был создан первый образец, способный умножать, делить, складывать и вычитать. Преимуществом над другими арифмометрами того времени было умение работать с тридцатизначными числами.Будучи предприимчивым бизнесменом, а в прошлом военным чиновником, Кольмар запатентовал устройство в том же году, однако коммерческим продуктом его изобретение стало только через 20 лет. В 1840 году он представил арифмометр на промышленной выставке во Франции, где занял серебро. Позже, когда удалось наладить производство, цена на арифмометр кусалась – 400 франков за штуку. Всего за год удавалось продать не более 100 машин, однако спрос и конкуренция росли из года в год.В 1851 году на выставке арифмометр Шарля де Кольмара также уступил первенство вычислительной машине Штаффеля. Компенсировать недостатки изобретения предприниматель решил более активной рекламой – он создал описание устройства и разослал его всей европейской знати, что позволило получить множество наград.На выставке в Париже в 1855 году Кольмар показал гигантский двухметровый арифмометр, для управления которым требовалось минимум 2 человека. Как вы уже могли догадаться, главный приз ушел другому изобретению из Швеции. К концу 1870-х спрос на арифмометры значительно вырос, а благодаря большим усилиям Кольмара, его арифмометр стал одним из самых востребованных на рынке.Особенности: Основан на принципе арифмометра Лейбница;В своё время превосходил все известные машины, так как мог оперировать тридцатизначными числами;Первый коммерческий арифмометр;Отличался надежностью, укоренился на конторских столах и отлично продавался в течение следующих 90 лет;За своё изобретение Тома был награжден орденом Почётного легиона.Вычислительная машина ШтаффеляВычислительная машина Штаффеля (1814-1884) –  арифмометр, созданный Израилем Авраамом Штаффелем. Разработка началась в 1835 году, а уже в 1845 был представлен первый рабочий образец на выставке в Варшаве. Штаффель родился в бедной еврейской семье, а потому не имел доступа к научным публикациям, где описывались арифмометры других изобретателей. Будучи часовщиком и проживая в Варшаве, он выучил польский язык и получил доступ к научной информации, издаваемой в Царстве Польском. Существует мнение, что эти факты делали арифмометр Штаффеля непохожим на другие разработки. В 1845 году на выставке в Варшаве Штаффеля наградили серебряной медалью. Этот факт поспособствовал тому, что царский наместник – князь Варшавский, генерал-фельдмаршал Иван Фёдорович Паскевич передал изобретателю 150 рублей для поездки в петербургскую Академию наук. Академики в Петербурге высоко оценили арифмометр Штаффеля, отмечая, что для умножения не требовалось последовательное складывание. В 1847 году машину показали императору Николаю I, который наградил Штаффеля из бюджета солидной по тем временам суммой в 1500 рублей серебром.Для понимания приблизительных цен того времени.А. Вегелин, 25 февраля 1833 г. из села Сретенского.\"Дороговизна в здешнем крае неимоверная сравнительно с Читою или с Петровским, вот тебе, милый друг, маленький образчик к ценам: пуд ржи 2 р, к весне будет, вероятно, дороже, пшеницы - 4 р., ярицы 1 р.90 коп, гречишная крупа 2 р 40 к., мясо пуд 3 р.50 к., летом же 4, пуд картофелю 1 р. 50 коп., масло 22 руб, работник на хозяйских харчах 5 р. в месяц, лошадь крестьяснкая порядочная от 50 до 60 р, корова хорошая 25 р... Пушной товар почти в одинаковой цене, как во всей Сибири, т.е. белка от 70 коп до 1 р, лисица красная 8 р, чернобурая 25, соболь летучий 25, старой медведь 12 р и 15 р, молодой 5 р.... Я плачу [за комнату] 15 р. в месяц.\"Как чувствовал себя Штаффель, когда получил 1500 рублей по приказу императора.На полученные деньги Штаффель улучшал изобретение, а уже в 1851 году забрал золотую медаль на большой выставке в Лондоне, обойдя Кольмара с его арифмометром. Несмотря на попытки популяризировать устройство с помощью выставок и прессы, спрос на счётные машины оставался низким, а издержки производства высокими.К сожалению, арифмометр так и не пошел в массовое производство. Потратив все свои сбережения на изобретения, Штаффель умер в бедности.Особенности: Ни один экземпляр машины не сохранился до XXI века;Конструкция арифмометра известна только по историческим источникам – статьи для прессы, отчёты и решения жюри c выставок;Разработка заняла 10 лет, а машина не была запатентована;Не пошла в массовое производство из-за недостатка спроса и финансирования;Была представлена в Санкт-Петербургской академии наук, где получила широкое признание среди академиков.Арифмометр ОднераАрифмометр Однера – один из самых популярных арифмометров в мире. Его разработкой занимался российско-шведский механик Вильгодт Теофил Однер (1845-1905).Интерес к арифмометром появился у Однера в 1871 году после ремонта арифмометра Шарля де Кольмара. Через пару лет он сделал первый опытный образец, а уже в 1877 году получил заказ на 14 штук от Людвига Нобеля – старшего брата учредителя Нобелевской премии Альфреда Нобеля. В последующие годы Однер запатентовал конструкцию в нескольких странах и к 1890 году наладил промышленное производство в Санкт-Петербурге, а в 1891 году – в Германии. Уже в 1892 году германское производство пришлось продать; после на заводе производили клоны арифмометров под брендом Brunsviga (по названию города Брауншвейга).В 1917 году грянула Октябрьская революция, под ноги которой попал и завод Однера в Петербурге.После национализации имущества в России потомки Однера создали новое производство в Швеции – Original-Odhner (“Настоящий Однер”). В 1924 году петербургский завод Однера перенесли в Москву, где и продолжили выпуск клонов под маркой “Феликс”. Подробнее ознакомиться с арифмометром можно в блоге Яндекс.Музея на Хабре или почитать инструкцию к этому аппарату. Особенности:Был распространён во всем мире и запатентован во многих странах;С его появлением зародилось математическое машиностроение, в течение многих десятков лет он был самой распространенной вычислительной машиной;Только распространение электронных калькуляторов вытеснило арифмометр Однера из всеобщего употребления;Клоны этой машины выпускались вплоть до второй половины 20 века, в том числе в России.НаследиеРазумеется, помимо рассмотренных в статье изобретений существовало множество других. В книгах Ю. Л. Полунова “От абака до компьютера” можно ознакомиться с историей счётных инструментов намного подробнее.Удобный, быстрый и точный счёт был необходим людям, независимо от эпохи и географии. Подобные инструменты стали естественной составляющей эволюции человечества и привели нас к современным ЭВМ.По хронологии изобретений чётко прослеживается усложнение и новаторство многих идей. Сперва люди начали с элементарного, а пришли к сложным механизмам и не остановились на достигнутом – позже появились машины с перфокартами и изобретения немецкого учёного Конрада Цузе, но это уже совсем другая история.",
        "user": "\n      Barseadar\n    ",
        "date": "13  октября  2004",
        "rating": " 52.76 \n    Рейтинг\n  ",
        "hab": "Блог компании Сервер Молл Математика *История IT Старое железо ",
        "time": "сегодня в 13:00",
        "sait": "\n      servermall.ru\n    "
    },
    {
        "url": "https://habr.com/ru/company/selectel/blog/584774/",
        "title": "Windows 95 OSR2 исполнилось 25 лет",
        "teg": "windows 95история ОСmicrosoft",
        "body": "\r\nВероятно, на Хабре не так много осталось пользователей, кто до сих пор тем либо иным образом продолжает работать с Windows 95. Возможно, эта ОС сохранилась на каких-либо промышленных системах, в организациях, где парк оборудования и ПО не обновлялись много лет, либо же Windows 95 нужна для каких-то специфических задач. \n\r\nКак бы там ни было, но в этом году версии Windows 95 OSR2 исполнилось 25 лет. Подумать только — четверть века. OSR2 добавила к оригинальной ОС много новых полезных функций, что способствовало популяризации этой операционной системы. Косвенно о количестве обновлений и дополнений может свидетельствовать размер дистрибутива — целых 80 МБ вместо 30 МБ оригинальной ОС. Давайте вспомним об этом обновлении и том, что оно добавило к Windows 95.\n\nЧто примечательного в обновлении? \r\nОно вывело ОС на новый уровень, так что Windows 92 OSR2 можно считать вполне современной операционной системой, конечно, с определенными допущениями. \n\nАппаратная часть \n\r\nНаверное, одно из наиболее важных нововведений Windows 95 OSR2 («B» version) — 32-разрядная файловая система FAT32. Она давала пользователю возможность работать с дисками огромного размера — вплоть до 8 ГБ. До этого работать можно было с дисками объемом до 2 ГБ.\n\r\nОбновление исправляло огромное количество ошибок, которых, конечно, было немало в свежей операционной системе. Еще более приятным для пользователей было добавление огромного количества драйверов для самых разных устройств, включая даже поддержку порта Infrared Communication Driver 2.0. В то время она была нужна не такому уж и большому количеству пользователей, но все же это было важно. \n\r\nКстати, именно в Windows 95 появился такой мощный инструмент, как мастер установки оборудования. Пользователям часто приходилось устанавливать новые устройства, и это не было простой задачей. Для того, чтобы облегчить жизнь пользователя, Microsoft разработала «мастер оборудования». В OSR2 работа мастера была оптимизирована. \n\n\r\nДо появления обновления Windows 95 при работе с этой ОС возникали ошибки у владельцев ПК с новыми на тот момент материнскими платами ATX. OSR2 ликвидировало подавляющее большинство проблем несовместимости. \n\n\n\nРабота в сети \n\r\nА еще в ОС появилась поддержка модемов с комбинированной передачей данных и голоса — это тоже было важно для того времени. \n\r\nНу а заодно были усовершенствованы и другие сетевые функции, часть из которых добавили. В числе последних включение поддержки приложений для управления сетями с использованием спецификации Desktop Management Interface 1.1 и работа с Novell NetWare 4.x.\n\r\nИ вот именно в OSR2 компания представила браузер Internet Explorer 3.0, который позволял без особых проблем и забот путешествовать по все еще не очень большому интернету. Браузер быстро завоевал популярность пользователей — хотя бы потому, что альтернатив ему почти не было. Для тех, у кого была возможность подключения к глобальной сети, в дистрибутив добавили программу электронной почты и систему просмотра новостей. Это были Microsoft Internet Mail и Microsoft Internet News соответственно. \n\r\nНу и, конечно, нельзя забывать и относительно прогрессивную Microsoft NetMeeting, программу, которая давала возможность организовывать электронные конференции, общаться с пользователями по сети и т.п. Пользователи NetMeeting при необходимости могли даже работать в сети с видеофайлами — речь, конечно, не о редактировании, а об обмене файлами и их просмотре. \n\nМультимедиа\n\r\nWindows 95 OSR2 — просто сокровище для любого пользователя, которому необходимо работать с медиафайлами. В ОС появилось несколько элементов, которые являются базовыми и сейчас, в 2021 году. \n\r\nРазработчики добавили набор драйверов DirectX, который предназначался, в основном, для обеспечения нормальной работы игр, созданных посредством Microsoft Game SDK. Среди таких игр — Final Doom. Основные компоненты DirectX — DirectDraw, организующий прямой доступ к видеоаппаратуре, DirectInput, который обеспечивал поддержку джойстиков, DirectPlay, обеспечивавший сетевые возможности и DirectSound для работы со звуковыми устройствами. \n\r\nВпервые введена поддержка OpenGL, которая до Windows 95 была доступна лишь в Windows NT. Ну а потом OpenGL стали добавлять и в операционные системы для обычных пользователей. \n\r\nСмена параметров экрана в «горячем» режиме. Речь идет о том, что до Windows 95 пользователям приходилось перезагружать ПК после смены разрешение экрана или других его параметров. После OSR2 эта необходимость отпала, перезагрузка уже не требовалась. \n\n\nСистема-долгожитель \r\nНесмотря на то, что вскоре после появления Windows 95 выпустила следующую ОС — Windows 98, предыдущая версия работала на ПК и ноутбуках пользователей еще очень долго. Так, по данным аналитического агентства International Data Corporation, в 2001 году Windows 95 занимала 57,4% рынка десктопных ОС. Windows 98 за тот же период освоила лишь 17,2% рынка. \n\nПо данным Microsoft, к концу 2002 года на 73% корпоративных ПК была установлена Windows 95, 98 или Windows NT Workstation 2.\n\nА что насчет современного использования Windows 95?\r\nВозможно, эта ОС управляет работой какого-то специфического оборудования на предприятиях. В целом же, Windows 95 перестали использовать много лет назад. Сейчас она служит в качестве развлечения вида «сделаем из хлеба троллейбус».\n\r\nТак, Windows 95 поставили на Nintendo DS.\n\n\r\nЭту ОС ухитрились запустить на Apple Watch. Правда, на загрузку системе понадобился целый час, несмотря на то, что характеристики даже первого поколения умных часов от Apple значительно превышают минимальные требования ОС.\n\n\r\nЕще Windows 95 установили внутри Minecraft, после чего в среде этой ОС поставили Doom, причем вполне играбельный.\n\n\r\nКроме того, эту операционную систему смогли поставить на PSP — причем еще в 2013 году. Это было, фактически, эмулирование через DosBox. При этом звук не работал, но большинство прочих функций работали. \n\n\r\nВ целом, опыты с Windows 95 продолжаются, ее пробуют ставить на самое экзотическое оборудование. Радует, что эту ОС не забывают энтузиасты.\n\n\n\n",
        "user": "\n      Greiv656\n    ",
        "date": "11  сентября  2007",
        "rating": " 1299.25 \n    Рейтинг\n  ",
        "hab": "Блог компании Selectel История IT Софт Настольные компьютеры ",
        "time": "вчера в 21:19",
        "sait": "\n      selectel.ru\n    "
    }
]